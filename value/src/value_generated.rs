// automatically generated by the FlatBuffers compiler, do not modify
// @generated

extern crate alloc;

#[allow(unused_imports, dead_code)]
pub mod data_model {

extern crate alloc;

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_VALUE_DATA: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_VALUE_DATA: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_VALUE_DATA: [ValueData; 11] = [
  ValueData::NONE,
  ValueData::Int,
  ValueData::Float,
  ValueData::Bool,
  ValueData::Text,
  ValueData::Time,
  ValueData::Date,
  ValueData::Array,
  ValueData::Dict,
  ValueData::Node,
  ValueData::Edge,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ValueData(pub u8);
#[allow(non_upper_case_globals)]
impl ValueData {
  pub const NONE: Self = Self(0);
  pub const Int: Self = Self(1);
  pub const Float: Self = Self(2);
  pub const Bool: Self = Self(3);
  pub const Text: Self = Self(4);
  pub const Time: Self = Self(5);
  pub const Date: Self = Self(6);
  pub const Array: Self = Self(7);
  pub const Dict: Self = Self(8);
  pub const Node: Self = Self(9);
  pub const Edge: Self = Self(10);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 10;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::Int,
    Self::Float,
    Self::Bool,
    Self::Text,
    Self::Time,
    Self::Date,
    Self::Array,
    Self::Dict,
    Self::Node,
    Self::Edge,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::Int => Some("Int"),
      Self::Float => Some("Float"),
      Self::Bool => Some("Bool"),
      Self::Text => Some("Text"),
      Self::Time => Some("Time"),
      Self::Date => Some("Date"),
      Self::Array => Some("Array"),
      Self::Dict => Some("Dict"),
      Self::Node => Some("Node"),
      Self::Edge => Some("Edge"),
      _ => None,
    }
  }
}
impl ::core::fmt::Debug for ValueData {
  fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> ::flatbuffers::Follow<'a> for ValueData {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { ::flatbuffers::read_scalar_at::<u8>(buf, loc) };
    Self(b)
  }
}

impl ::flatbuffers::Push for ValueData {
    type Output = ValueData;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { ::flatbuffers::emplace_scalar::<u8>(dst, self.0) };
    }
}

impl ::flatbuffers::EndianScalar for ValueData {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> ::flatbuffers::Verifiable for ValueData {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    u8::run_verifier(v, pos)
  }
}

impl ::flatbuffers::SimpleToVerifyInSlice for ValueData {}
pub struct ValueDataUnionTableOffset {}

pub enum IntOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Int<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for Int<'a> {
  type Inner = Int<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Int<'a> {
  pub const VT_VALUE: ::flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    Int { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args IntArgs
  ) -> ::flatbuffers::WIPOffset<Int<'bldr>> {
    let mut builder = IntBuilder::new(_fbb);
    builder.add_value(args.value);
    builder.finish()
  }


  #[inline]
  pub fn value(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(Int::VT_VALUE, Some(0)).unwrap()}
  }
}

impl ::flatbuffers::Verifiable for Int<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<i64>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct IntArgs {
    pub value: i64,
}
impl<'a> Default for IntArgs {
  #[inline]
  fn default() -> Self {
    IntArgs {
      value: 0,
    }
  }
}

pub struct IntBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> IntBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_value(&mut self, value: i64) {
    self.fbb_.push_slot::<i64>(Int::VT_VALUE, value, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> IntBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    IntBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<Int<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for Int<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("Int");
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum FloatOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Float<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for Float<'a> {
  type Inner = Float<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Float<'a> {
  pub const VT_NUMBER: ::flatbuffers::VOffsetT = 4;
  pub const VT_SHIFT: ::flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    Float { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args FloatArgs
  ) -> ::flatbuffers::WIPOffset<Float<'bldr>> {
    let mut builder = FloatBuilder::new(_fbb);
    builder.add_number(args.number);
    builder.add_shift(args.shift);
    builder.finish()
  }


  #[inline]
  pub fn number(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(Float::VT_NUMBER, Some(0)).unwrap()}
  }
  #[inline]
  pub fn shift(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(Float::VT_SHIFT, Some(0)).unwrap()}
  }
}

impl ::flatbuffers::Verifiable for Float<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<i64>("number", Self::VT_NUMBER, false)?
     .visit_field::<u8>("shift", Self::VT_SHIFT, false)?
     .finish();
    Ok(())
  }
}
pub struct FloatArgs {
    pub number: i64,
    pub shift: u8,
}
impl<'a> Default for FloatArgs {
  #[inline]
  fn default() -> Self {
    FloatArgs {
      number: 0,
      shift: 0,
    }
  }
}

pub struct FloatBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> FloatBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_number(&mut self, number: i64) {
    self.fbb_.push_slot::<i64>(Float::VT_NUMBER, number, 0);
  }
  #[inline]
  pub fn add_shift(&mut self, shift: u8) {
    self.fbb_.push_slot::<u8>(Float::VT_SHIFT, shift, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> FloatBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    FloatBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<Float<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for Float<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("Float");
      ds.field("number", &self.number());
      ds.field("shift", &self.shift());
      ds.finish()
  }
}
pub enum BoolOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Bool<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for Bool<'a> {
  type Inner = Bool<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Bool<'a> {
  pub const VT_VALUE: ::flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    Bool { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args BoolArgs
  ) -> ::flatbuffers::WIPOffset<Bool<'bldr>> {
    let mut builder = BoolBuilder::new(_fbb);
    builder.add_value(args.value);
    builder.finish()
  }


  #[inline]
  pub fn value(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Bool::VT_VALUE, Some(false)).unwrap()}
  }
}

impl ::flatbuffers::Verifiable for Bool<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<bool>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct BoolArgs {
    pub value: bool,
}
impl<'a> Default for BoolArgs {
  #[inline]
  fn default() -> Self {
    BoolArgs {
      value: false,
    }
  }
}

pub struct BoolBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> BoolBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_value(&mut self, value: bool) {
    self.fbb_.push_slot::<bool>(Bool::VT_VALUE, value, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> BoolBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    BoolBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<Bool<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for Bool<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("Bool");
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum TextOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Text<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for Text<'a> {
  type Inner = Text<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Text<'a> {
  pub const VT_VALUE: ::flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    Text { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TextArgs<'args>
  ) -> ::flatbuffers::WIPOffset<Text<'bldr>> {
    let mut builder = TextBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    builder.finish()
  }


  #[inline]
  pub fn value(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(Text::VT_VALUE, None)}
  }
}

impl ::flatbuffers::Verifiable for Text<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct TextArgs<'a> {
    pub value: Option<::flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for TextArgs<'a> {
  #[inline]
  fn default() -> Self {
    TextArgs {
      value: None,
    }
  }
}

pub struct TextBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> TextBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_value(&mut self, value: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Text::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> TextBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TextBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<Text<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for Text<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("Text");
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum TimeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Time<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for Time<'a> {
  type Inner = Time<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Time<'a> {
  pub const VT_MS: ::flatbuffers::VOffsetT = 4;
  pub const VT_NS: ::flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    Time { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TimeArgs
  ) -> ::flatbuffers::WIPOffset<Time<'bldr>> {
    let mut builder = TimeBuilder::new(_fbb);
    builder.add_ms(args.ms);
    builder.add_ns(args.ns);
    builder.finish()
  }


  #[inline]
  pub fn ms(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(Time::VT_MS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ns(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Time::VT_NS, Some(0)).unwrap()}
  }
}

impl ::flatbuffers::Verifiable for Time<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<i64>("ms", Self::VT_MS, false)?
     .visit_field::<u32>("ns", Self::VT_NS, false)?
     .finish();
    Ok(())
  }
}
pub struct TimeArgs {
    pub ms: i64,
    pub ns: u32,
}
impl<'a> Default for TimeArgs {
  #[inline]
  fn default() -> Self {
    TimeArgs {
      ms: 0,
      ns: 0,
    }
  }
}

pub struct TimeBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> TimeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_ms(&mut self, ms: i64) {
    self.fbb_.push_slot::<i64>(Time::VT_MS, ms, 0);
  }
  #[inline]
  pub fn add_ns(&mut self, ns: u32) {
    self.fbb_.push_slot::<u32>(Time::VT_NS, ns, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> TimeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TimeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<Time<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for Time<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("Time");
      ds.field("ms", &self.ms());
      ds.field("ns", &self.ns());
      ds.finish()
  }
}
pub enum DateOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Date<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for Date<'a> {
  type Inner = Date<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Date<'a> {
  pub const VT_DAYS: ::flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    Date { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DateArgs
  ) -> ::flatbuffers::WIPOffset<Date<'bldr>> {
    let mut builder = DateBuilder::new(_fbb);
    builder.add_days(args.days);
    builder.finish()
  }


  #[inline]
  pub fn days(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(Date::VT_DAYS, Some(0)).unwrap()}
  }
}

impl ::flatbuffers::Verifiable for Date<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<i64>("days", Self::VT_DAYS, false)?
     .finish();
    Ok(())
  }
}
pub struct DateArgs {
    pub days: i64,
}
impl<'a> Default for DateArgs {
  #[inline]
  fn default() -> Self {
    DateArgs {
      days: 0,
    }
  }
}

pub struct DateBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> DateBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_days(&mut self, days: i64) {
    self.fbb_.push_slot::<i64>(Date::VT_DAYS, days, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> DateBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<Date<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for Date<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("Date");
      ds.field("days", &self.days());
      ds.finish()
  }
}
pub enum ArrayOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Array<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for Array<'a> {
  type Inner = Array<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Array<'a> {
  pub const VT_VALUES: ::flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    Array { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ArrayArgs<'args>
  ) -> ::flatbuffers::WIPOffset<Array<'bldr>> {
    let mut builder = ArrayBuilder::new(_fbb);
    if let Some(x) = args.values { builder.add_values(x); }
    builder.finish()
  }


  #[inline]
  pub fn values(&self) -> Option<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Value<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Value>>>>(Array::VT_VALUES, None)}
  }
}

impl ::flatbuffers::Verifiable for Array<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<Value>>>>("values", Self::VT_VALUES, false)?
     .finish();
    Ok(())
  }
}
pub struct ArrayArgs<'a> {
    pub values: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Value<'a>>>>>,
}
impl<'a> Default for ArrayArgs<'a> {
  #[inline]
  fn default() -> Self {
    ArrayArgs {
      values: None,
    }
  }
}

pub struct ArrayBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> ArrayBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_values(&mut self, values: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , ::flatbuffers::ForwardsUOffset<Value<'b >>>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Array::VT_VALUES, values);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> ArrayBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ArrayBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<Array<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for Array<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("Array");
      ds.field("values", &self.values());
      ds.finish()
  }
}
pub enum DictEntryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DictEntry<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for DictEntry<'a> {
  type Inner = DictEntry<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> DictEntry<'a> {
  pub const VT_KEY: ::flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: ::flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    DictEntry { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DictEntryArgs<'args>
  ) -> ::flatbuffers::WIPOffset<DictEntry<'bldr>> {
    let mut builder = DictEntryBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    if let Some(x) = args.key { builder.add_key(x); }
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(DictEntry::VT_KEY, None)}
  }
  #[inline]
  pub fn value(&self) -> Option<Value<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<Value>>(DictEntry::VT_VALUE, None)}
  }
}

impl ::flatbuffers::Verifiable for DictEntry<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<Value>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct DictEntryArgs<'a> {
    pub key: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<::flatbuffers::WIPOffset<Value<'a>>>,
}
impl<'a> Default for DictEntryArgs<'a> {
  #[inline]
  fn default() -> Self {
    DictEntryArgs {
      key: None,
      value: None,
    }
  }
}

pub struct DictEntryBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> DictEntryBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key(&mut self, key: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(DictEntry::VT_KEY, key);
  }
  #[inline]
  pub fn add_value(&mut self, value: ::flatbuffers::WIPOffset<Value<'b >>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<Value>>(DictEntry::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> DictEntryBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DictEntryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<DictEntry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for DictEntry<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("DictEntry");
      ds.field("key", &self.key());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum DictOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Dict<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for Dict<'a> {
  type Inner = Dict<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Dict<'a> {
  pub const VT_ENTRIES: ::flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    Dict { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DictArgs<'args>
  ) -> ::flatbuffers::WIPOffset<Dict<'bldr>> {
    let mut builder = DictBuilder::new(_fbb);
    if let Some(x) = args.entries { builder.add_entries(x); }
    builder.finish()
  }


  #[inline]
  pub fn entries(&self) -> Option<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<DictEntry<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<DictEntry>>>>(Dict::VT_ENTRIES, None)}
  }
}

impl ::flatbuffers::Verifiable for Dict<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<DictEntry>>>>("entries", Self::VT_ENTRIES, false)?
     .finish();
    Ok(())
  }
}
pub struct DictArgs<'a> {
    pub entries: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<DictEntry<'a>>>>>,
}
impl<'a> Default for DictArgs<'a> {
  #[inline]
  fn default() -> Self {
    DictArgs {
      entries: None,
    }
  }
}

pub struct DictBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> DictBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_entries(&mut self, entries: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , ::flatbuffers::ForwardsUOffset<DictEntry<'b >>>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Dict::VT_ENTRIES, entries);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> DictBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DictBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<Dict<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for Dict<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("Dict");
      ds.field("entries", &self.entries());
      ds.finish()
  }
}
pub enum NodeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Node<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for Node<'a> {
  type Inner = Node<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Node<'a> {
  pub const VT_ID: ::flatbuffers::VOffsetT = 4;
  pub const VT_LABELS: ::flatbuffers::VOffsetT = 6;
  pub const VT_PROPERTIES: ::flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    Node { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args NodeArgs<'args>
  ) -> ::flatbuffers::WIPOffset<Node<'bldr>> {
    let mut builder = NodeBuilder::new(_fbb);
    builder.add_id(args.id);
    if let Some(x) = args.properties { builder.add_properties(x); }
    if let Some(x) = args.labels { builder.add_labels(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(Node::VT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn labels(&self) -> Option<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<&'a str>>>>(Node::VT_LABELS, None)}
  }
  #[inline]
  pub fn properties(&self) -> Option<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<DictEntry<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<DictEntry>>>>(Node::VT_PROPERTIES, None)}
  }
}

impl ::flatbuffers::Verifiable for Node<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<i64>("id", Self::VT_ID, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<&'_ str>>>>("labels", Self::VT_LABELS, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<DictEntry>>>>("properties", Self::VT_PROPERTIES, false)?
     .finish();
    Ok(())
  }
}
pub struct NodeArgs<'a> {
    pub id: i64,
    pub labels: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub properties: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<DictEntry<'a>>>>>,
}
impl<'a> Default for NodeArgs<'a> {
  #[inline]
  fn default() -> Self {
    NodeArgs {
      id: 0,
      labels: None,
      properties: None,
    }
  }
}

pub struct NodeBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> NodeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: i64) {
    self.fbb_.push_slot::<i64>(Node::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_labels(&mut self, labels: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , ::flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Node::VT_LABELS, labels);
  }
  #[inline]
  pub fn add_properties(&mut self, properties: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , ::flatbuffers::ForwardsUOffset<DictEntry<'b >>>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Node::VT_PROPERTIES, properties);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> NodeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    NodeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<Node<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for Node<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("Node");
      ds.field("id", &self.id());
      ds.field("labels", &self.labels());
      ds.field("properties", &self.properties());
      ds.finish()
  }
}
pub enum EdgeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Edge<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for Edge<'a> {
  type Inner = Edge<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Edge<'a> {
  pub const VT_ID: ::flatbuffers::VOffsetT = 4;
  pub const VT_LABEL: ::flatbuffers::VOffsetT = 6;
  pub const VT_START_ID: ::flatbuffers::VOffsetT = 8;
  pub const VT_END_ID: ::flatbuffers::VOffsetT = 10;
  pub const VT_PROPERTIES: ::flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    Edge { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args EdgeArgs<'args>
  ) -> ::flatbuffers::WIPOffset<Edge<'bldr>> {
    let mut builder = EdgeBuilder::new(_fbb);
    builder.add_end_id(args.end_id);
    builder.add_start_id(args.start_id);
    builder.add_id(args.id);
    if let Some(x) = args.properties { builder.add_properties(x); }
    if let Some(x) = args.label { builder.add_label(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(Edge::VT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn label(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(Edge::VT_LABEL, None)}
  }
  #[inline]
  pub fn start_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Edge::VT_START_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn end_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Edge::VT_END_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn properties(&self) -> Option<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<DictEntry<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<DictEntry>>>>(Edge::VT_PROPERTIES, None)}
  }
}

impl ::flatbuffers::Verifiable for Edge<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<i64>("id", Self::VT_ID, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("label", Self::VT_LABEL, false)?
     .visit_field::<u64>("start_id", Self::VT_START_ID, false)?
     .visit_field::<u64>("end_id", Self::VT_END_ID, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<DictEntry>>>>("properties", Self::VT_PROPERTIES, false)?
     .finish();
    Ok(())
  }
}
pub struct EdgeArgs<'a> {
    pub id: i64,
    pub label: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub start_id: u64,
    pub end_id: u64,
    pub properties: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<DictEntry<'a>>>>>,
}
impl<'a> Default for EdgeArgs<'a> {
  #[inline]
  fn default() -> Self {
    EdgeArgs {
      id: 0,
      label: None,
      start_id: 0,
      end_id: 0,
      properties: None,
    }
  }
}

pub struct EdgeBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> EdgeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: i64) {
    self.fbb_.push_slot::<i64>(Edge::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_label(&mut self, label: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Edge::VT_LABEL, label);
  }
  #[inline]
  pub fn add_start_id(&mut self, start_id: u64) {
    self.fbb_.push_slot::<u64>(Edge::VT_START_ID, start_id, 0);
  }
  #[inline]
  pub fn add_end_id(&mut self, end_id: u64) {
    self.fbb_.push_slot::<u64>(Edge::VT_END_ID, end_id, 0);
  }
  #[inline]
  pub fn add_properties(&mut self, properties: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , ::flatbuffers::ForwardsUOffset<DictEntry<'b >>>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Edge::VT_PROPERTIES, properties);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> EdgeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    EdgeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<Edge<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for Edge<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("Edge");
      ds.field("id", &self.id());
      ds.field("label", &self.label());
      ds.field("start_id", &self.start_id());
      ds.field("end_id", &self.end_id());
      ds.field("properties", &self.properties());
      ds.finish()
  }
}
pub enum ValueOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Value<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for Value<'a> {
  type Inner = Value<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Value<'a> {
  pub const VT_DATA_TYPE: ::flatbuffers::VOffsetT = 4;
  pub const VT_DATA: ::flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    Value { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ValueArgs
  ) -> ::flatbuffers::WIPOffset<Value<'bldr>> {
    let mut builder = ValueBuilder::new(_fbb);
    if let Some(x) = args.data { builder.add_data(x); }
    builder.add_data_type(args.data_type);
    builder.finish()
  }


  #[inline]
  pub fn data_type(&self) -> ValueData {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ValueData>(Value::VT_DATA_TYPE, Some(ValueData::NONE)).unwrap()}
  }
  #[inline]
  pub fn data(&self) -> Option<::flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Table<'a>>>(Value::VT_DATA, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_int(&self) -> Option<Int<'a>> {
    if self.data_type() == ValueData::Int {
      self.data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Int::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_float(&self) -> Option<Float<'a>> {
    if self.data_type() == ValueData::Float {
      self.data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Float::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_bool(&self) -> Option<Bool<'a>> {
    if self.data_type() == ValueData::Bool {
      self.data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Bool::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_text(&self) -> Option<Text<'a>> {
    if self.data_type() == ValueData::Text {
      self.data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Text::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_time(&self) -> Option<Time<'a>> {
    if self.data_type() == ValueData::Time {
      self.data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Time::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_date(&self) -> Option<Date<'a>> {
    if self.data_type() == ValueData::Date {
      self.data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Date::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_array(&self) -> Option<Array<'a>> {
    if self.data_type() == ValueData::Array {
      self.data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Array::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_dict(&self) -> Option<Dict<'a>> {
    if self.data_type() == ValueData::Dict {
      self.data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Dict::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_node(&self) -> Option<Node<'a>> {
    if self.data_type() == ValueData::Node {
      self.data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Node::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_edge(&self) -> Option<Edge<'a>> {
    if self.data_type() == ValueData::Edge {
      self.data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Edge::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl ::flatbuffers::Verifiable for Value<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_union::<ValueData, _>("data_type", Self::VT_DATA_TYPE, "data", Self::VT_DATA, false, |key, v, pos| {
        match key {
          ValueData::Int => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<Int>>("ValueData::Int", pos),
          ValueData::Float => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<Float>>("ValueData::Float", pos),
          ValueData::Bool => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<Bool>>("ValueData::Bool", pos),
          ValueData::Text => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<Text>>("ValueData::Text", pos),
          ValueData::Time => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<Time>>("ValueData::Time", pos),
          ValueData::Date => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<Date>>("ValueData::Date", pos),
          ValueData::Array => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<Array>>("ValueData::Array", pos),
          ValueData::Dict => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<Dict>>("ValueData::Dict", pos),
          ValueData::Node => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<Node>>("ValueData::Node", pos),
          ValueData::Edge => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<Edge>>("ValueData::Edge", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct ValueArgs {
    pub data_type: ValueData,
    pub data: Option<::flatbuffers::WIPOffset<::flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for ValueArgs {
  #[inline]
  fn default() -> Self {
    ValueArgs {
      data_type: ValueData::NONE,
      data: None,
    }
  }
}

pub struct ValueBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> ValueBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_data_type(&mut self, data_type: ValueData) {
    self.fbb_.push_slot::<ValueData>(Value::VT_DATA_TYPE, data_type, ValueData::NONE);
  }
  #[inline]
  pub fn add_data(&mut self, data: ::flatbuffers::WIPOffset<::flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Value::VT_DATA, data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> ValueBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ValueBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<Value<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for Value<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("Value");
      ds.field("data_type", &self.data_type());
      match self.data_type() {
        ValueData::Int => {
          if let Some(x) = self.data_as_int() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ValueData::Float => {
          if let Some(x) = self.data_as_float() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ValueData::Bool => {
          if let Some(x) = self.data_as_bool() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ValueData::Text => {
          if let Some(x) = self.data_as_text() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ValueData::Time => {
          if let Some(x) = self.data_as_time() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ValueData::Date => {
          if let Some(x) = self.data_as_date() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ValueData::Array => {
          if let Some(x) = self.data_as_array() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ValueData::Dict => {
          if let Some(x) = self.data_as_dict() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ValueData::Node => {
          if let Some(x) = self.data_as_node() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ValueData::Edge => {
          if let Some(x) = self.data_as_edge() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("data", &x)
        },
      };
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `Value`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_value_unchecked`.
pub fn root_as_value(buf: &[u8]) -> Result<Value<'_>, ::flatbuffers::InvalidFlatbuffer> {
  ::flatbuffers::root::<Value>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Value` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_value_unchecked`.
pub fn size_prefixed_root_as_value(buf: &[u8]) -> Result<Value<'_>, ::flatbuffers::InvalidFlatbuffer> {
  ::flatbuffers::size_prefixed_root::<Value>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Value` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_value_unchecked`.
pub fn root_as_value_with_opts<'b, 'o>(
  opts: &'o ::flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Value<'b>, ::flatbuffers::InvalidFlatbuffer> {
  ::flatbuffers::root_with_opts::<Value<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Value` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_value_unchecked`.
pub fn size_prefixed_root_as_value_with_opts<'b, 'o>(
  opts: &'o ::flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Value<'b>, ::flatbuffers::InvalidFlatbuffer> {
  ::flatbuffers::size_prefixed_root_with_opts::<Value<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Value and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Value`.
pub unsafe fn root_as_value_unchecked(buf: &[u8]) -> Value<'_> {
  unsafe { ::flatbuffers::root_unchecked::<Value>(buf) }
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Value and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Value`.
pub unsafe fn size_prefixed_root_as_value_unchecked(buf: &[u8]) -> Value<'_> {
  unsafe { ::flatbuffers::size_prefixed_root_unchecked::<Value>(buf) }
}
#[inline]
pub fn finish_value_buffer<'a, 'b, A: ::flatbuffers::Allocator + 'a>(
    fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
    root: ::flatbuffers::WIPOffset<Value<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_value_buffer<'a, 'b, A: ::flatbuffers::Allocator + 'a>(fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>, root: ::flatbuffers::WIPOffset<Value<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod DataModel

